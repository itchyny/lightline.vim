*lightline.txt*	A light and configurable statusline/tabline for Vim

Version: 0.0
Author: itchyny (https://github.com/itchyny)
License: MIT License
Repository: https://github.com/itchyny/lightline.vim
Last Change: 2013/09/10 20:40:34.

CONTENTS					*lightline-contents*

Introduction				|lightline-introduction|
Spirit					|lightline-spirit|
Option					|lightline-option|
Font					|lightline-font|
Function				|lightline-function|
Component Expansion			|lightline-component-expansion|
Examples				|lightline-examples|
Nice Examples				|lightline-nice-examples|
Powerful Example			|lightline-powerful-example|
Troubleshooting				|lightline-troubleshooting|
Changelog				|lightline-changelog|

==============================================================================
INTRODUCTION					*lightline-introduction*

The *lightline* plugin is a light and configurable statusline/tabline for Vim.

------------------------------------------------------------------------------
SPIRIT						*lightline-spirit*

	Minimalism
	    The core script is very small.

	Configurability
	    You can create your own component and easily add to the
	    statusline/tabline.

	Orthogonality
	    Any plugin should not change the settings of another plugin.
	    Such plugin-crossing settings should be written by users in
	    .vimrc.

	You might find this plugin is not so useful by default. This plugin
	does not provide the branch information, which is a very basic
	component in existing plugins. The reason is that branch component is
	one of plugin-crossing settings so users should write the settings
	using the APIs of the both plugins. Hospitality makes a plugin messy.
	Good APIs keep a plugin clean.

------------------------------------------------------------------------------
OPTIONS						*lightline-option*

	g:lightline				*g:lightline*
		All the options are stored into this global variable.

	g:lightline.active			*g:lightline.active*
	g:lightline.inactive			*g:lightline.inactive*
	g:lightline.tabline			*g:lightline.tabline*
		Dictionaries to specify the statusline/tabline components.
		The components are gathered from either |g:lightline.component|,
		|g:lightline.component_function| or
		|g:lightline.component_expand|.
		Note that right groups of components are stored from right to
		left. The default values are:
>
		let g:lightline.active = {
		    \ 'left': [ [ 'mode', 'paste' ],
		    \           [ 'readonly', 'filename', 'modified' ] ],
		    \ 'right': [ [ 'lineinfo' ],
		    \            [ 'percent' ],
		    \            [ 'fileformat', 'fileencoding', 'filetype' ] ] }
		let g:lightline.inactive = {
		    \ 'left': [ [ 'filename' ] ],
		    \ 'right': [ [ 'lineinfo' ],
		    \            [ 'percent' ] ] }
		let g:lightline.tabline = {
		    \ 'left': [ [ 'tabs' ] ],
		    \ 'right': [ [ 'close' ] ] }
<
	g:lightline.tab				*g:lightline.tab*
		Dictionaries to specify the components in each tabs.
		The components are gathered from either
		|g:lightline.tab_component| or
		|g:lightline.tab_component_function|.
		The default values are:
>
		let g:lightline.tab = {
		    \ 'active': [ 'tabnum', 'filename', 'modified' ],
		    \ 'inactive': [ 'tabnum', 'filename', 'modified' ] }
<
	g:lightline.component			*g:lightline.component*
		Dictionary for statusline/tabline components.
		The default value is:
>
		let g:lightline.component = {
		    \ 'mode': '%{lightline#mode()}',
		    \ 'absolutepath': '%F',
		    \ 'relativepath': '%f',
		    \ 'filename': '%t',
		    \ 'modified': '%M',
		    \ 'bufnum': '%n',
		    \ 'paste': '%{&paste?"PASTE":""}',
		    \ 'readonly': '%R',
		    \ 'charvalue': '%b',
		    \ 'charvaluehex': '%B',
		    \ 'fileencoding': '%{strlen(&fenc)?&fenc:&enc}',
		    \ 'fileformat': '%{&fileformat}',
		    \ 'filetype': '%{strlen(&filetype)?&filetype:"no ft"}',
		    \ 'percent': '%3p%%',
		    \ 'percentwin': '%P',
		    \ 'lineinfo': '%3l:%-2v',
		    \ 'line': '%l',
		    \ 'column': '%c'
		    \ 'close': '%999X X ' }
<
	g:lightline.component_visible_condition		*g:lightline.component_visible_condition*
		Dictionary of boolean expressions for the components.
		Each expression should correspond to the condition each
		component have non-zero length.
		The default value is:
>
		let g:lightline.component_visible_condition = {
		    \ 'modified': '&modified||!&modifiable',
		    \ 'readonly': '&readonly',
		    \ 'paste': '&paste' }
<
		Users are recommended to set this option together with the
		component itself.

	g:lightline.component_function		*g:lightline.component_function*
		Another dictionary for components. This is more convenient
		because the user does not have to set both component and
		component_visible_condition. If a component set to both component and
		component_function, the setting of component_function has priority.
		For example, if you want a component for read-only mark, which
		disappears in help windows:
>
		let g:lightline = {
			\ 'active': {
			\   'left': [ [ 'mode', 'paste' ],
			\             [ 'myreadonly', 'filename', 'modified' ] ],
			\ },
			\ 'component_function': {
			\   'myreadonly': 'MyReadonly'
			\ },
			\ }
		function! MyReadonly()
			return &ft !~? 'help' && &readonly ? 'RO' : ''
		endfunction
<
	g:lightline.component_expand		*g:lightline.component_expand*
		Another dictionary for components. You can create a component
		which has a special color. For example, error components or
		warning components. The functions should return one of:
			+ a string
			+ an array of three elements:
				[[ left ], [ middle ], [ right ]]
		The component in this dictionary has priority over
		|g:lightline.component| and |g:lightline.component_function|.
		See |lightline-component-expansion| for more detail.
>
		let g:lightline.component_expand = {
		    \ 'tabs': 'lightline#tabs' }
<
	g:lightline.component_type		*g:lightline.component_type*
		A dictionary to specify the types for components in
		|g:lightline.component_expand|. The types are used to specify
		the color. Specifically, the type raw is used to specify a
		component which should not be wrapped by item group: %(...%).
>
		let g:lightline.component_type = {
		    \ 'tabs': 'tabsel',
		    \ 'close': 'raw' }
<
	g:lightline.tab_component		*g:lightline.tab_component*
		A dictionary for components in one tab.

	g:lightline.tab_component_function	*g:lightline.tab_component_function*
		Another dictionary for components in one tab.
		A function specified as a tab component takes one argument:
		the tab [count].
		The default value is:
>
		let g:lightline.tab_component_function = {
		      \ 'filename': 'lightline#tab#filename',
		      \ 'modified': 'lightline#tab#modified',
		      \ 'readonly': 'lightline#tab#readonly',
		      \ 'tabnum': 'lightline#tab#tabnum' }
<
	g:lightline.colorscheme			*g:lightline.colorscheme*
		The colorscheme for lightline.vim.
		Currently, wombat, solarized, powerline, jellybeans, Tomorrow,
		Tomorrow_Night, Tomorrow_Night_Blue, Tomorrow_Night_Eighties
		and landscape are available.
		The default value is:
>
		let g:lightline.colorscheme = 'default'
<
		Note that the default colorscheme is exactly the same as the
		powerline theme.

	g:lightline.mode_map			*g:lightline.mode_map*
		A dictionary of names for mode.
		The default value is:
>
		let g:lightline.mode_map = {
		    \ 'n' : 'NORMAL',
		    \ 'i' : 'INSERT',
		    \ 'R' : 'REPLACE',
		    \ 'v' : 'VISUAL',
		    \ 'V' : 'V-LINE',
		    \ 'c' : 'COMMAND',
		    \ "\<C-v>": 'V-BLOCK',
		    \ 's' : 'SELECT',
		    \ 'S' : 'S-LINE',
		    \ "\<C-s>": 'S-BLOCK',
		    \ '?': '      ' }
<
		When you search a word, you get into the command mode. But if
		you want to keep the mode indicator as 'NORMAL', add
>
		let g:lightline.mode_map.c = 'NORMAL'
<
		to your .vimrc.

	g:lightline.separator			*g:lightline.separator*
	g:lightline.subseparator		*g:lightline.subseparator*
		Dictionaries to store separators.
		The default value is
>
		let g:lightline.separator = { 'left': '', 'right': '' }
		let g:lightline.subseparator = { 'left': '|', 'right': '|' }
<
	g:lightline.enable			*g:lightline.enable*
		A dictionary to specify which feature is turned on.
		The default value is
>
		let g:lightline.enable = {
		    \ 'statusline': 1
		    \ 'tabline': 1
		    \ }
<

==============================================================================
FONT						*lightline-font*
You can use the patched font you used for |vim-powerline| and |powerline|.

The patched fonts for |powerline| are available at
https://github.com/Lokaltog/powerline-fonts

A tutorial to create a patched font for |vim-powerline| is available at
https://github.com/Lokaltog/vim-powerline/tree/develop/fontpatcher

If you have installed the patched font for |powerline|, following settings look
nice.
>
	let g:lightline = {
		\ 'component': {
		\   'lineinfo': ' %3l:%-2v',
		\ },
		\ 'component_function': {
		\   'readonly': 'MyReadonly',
		\   'fugitive': 'MyFugitive'
		\ },
		\ 'separator': { 'left': '', 'right': '' },
		\ 'subseparator': { 'left': '', 'right': '' }
		\ }
	function! MyReadonly()
		return &readonly ? '' : ''
	endfunction
	function! MyFugitive()
		if exists("*fugitive#head")
			let _ = fugitive#head()
			return strlen(_) ? ''._ : ''
		endif
		return ''
	endfunction
<
If you have installed the patched font for |vim-powerline|, following settings
look nice.
>
	let g:lightline = {
		\ 'component': {
		\   'lineinfo': '⭡ %3l:%-2v',
		\ },
		\ 'component_function': {
		\   'readonly': 'MyReadonly',
		\   'fugitive': 'MyFugitive'
		\ },
		\ 'separator': { 'left': '⮀', 'right': '⮂' },
		\ 'subseparator': { 'left': '⮁', 'right': '⮃' }
		\ }
	function! MyReadonly()
		return &readonly ? '⭤' : ''
	endfunction
	function! MyFugitive()
		if exists("*fugitive#head")
			let _ = fugitive#head()
			return strlen(_) ? '⭠ '._ : ''
		endif
		return ''
	endfunction
<

==============================================================================
FUNCTION					*lightline-function*
Exposed functions for lightline.vim.

	lightline#mode()			*lightline#mode()*
		Returns the mode of the Vim using |g:lightline.mode_map|.

	lightline#init()			*lightline#init()*
		Initializes the variable |g:lightline|.

	lightline#colorscheme()			*lightline#colorscheme()*
		Initializes the colorscheme and the highlight groups.

	lightline#update()			*lightline#update()*
		Updates all the statuslines of existing windows.

	lightline#update_once()			*lightline#update_once()*
		Updates the statuslines only once.

	lightline#link([mode])			*lightline#link()*
		Creates links of the highlight groups for the active window.
		This function accepts an optional argument. It should be one
		of the return value of |mode()|.

	lightline#highlight()			*lightline#highlight()*
		Set the highlight groups.

	lightline#statusline({inactive})	*lightline#statusline()*
		Returns |statusline| strings. If the argument is 0, it returns
		the statusline for active window, and the statusline for
		inactive window otherwise.

	lightline#tabline()			*lightline#tabline()*
		Returns the tabline string.

	lightline#concatenate({list}, {num})	*lightline#concatenate()*
		A string concatenation function. Concatenating all the strings
		in {list} using the sub-separator of lightline. If {num} is 0,
		then the left sub-separator is used. Otherwise, the right
		sub-separator is used.


==============================================================================
COMPONENT EXPANSION				*lightline-component-expansion*
You can create components, which have specific colors. This section gives an
example using |syntastic|.

If you want to add the |syntastic| flag to the statusline, an easy example is:
>
	" Example A
	let g:lightline = {
	      \ 'active': {
	      \   'right': [ [ 'lineinfo', 'syntastic' ],
	      \              [ 'percent' ],
	      \              [ 'fileformat', 'fileencoding', 'filetype' ] ]
	      \ },
	      \ 'component_function': {
	      \   'syntastic': 'SyntasticStatuslineFlag',
	      \ }
	      \ }
	let g:syntastic_mode_map = { 'mode': 'passive',
	      \                      'active_filetypes': ['c', 'cpp'] }
<
However, the color of the syntastic component is the same as the lineinfo
component.

In order to change the syntastic component more outstanding, you have to use
|g:lightline.component_expand|. See the following example:
>
	" Example B
	let g:lightline = {
	      \ 'active': {
	      \   'right': [ [ 'syntastic', 'lineinfo' ],
	      \              [ 'percent' ],
	      \              [ 'fileformat', 'fileencoding', 'filetype' ] ]
	      \ },
	      \ 'component_expand': {
	      \   'syntastic': 'SyntasticStatuslineFlag',
	      \ },
	      \ 'component_type': {
	      \   'syntastic': 'error',
	      \ }
	      \ }
	let g:syntastic_mode_map = { 'mode': 'passive' }
	augroup AutoSyntastic
	  autocmd!
	  autocmd BufWritePost *.c,*.cpp call s:syntastic()
	augroup END
	function! s:syntastic()
	  SyntasticCheck
	  call lightline#update()
	endfunction
<
In order to understand the above codes, you firstly should know how the
colorschemes work in lightline.vim. Open the following file.
		autoload/lightline/colorscheme/powerline.vim
The colorscheme is created by one dictionary: s:p (abbreviation for palette).
See the value of s:p.normal.right.
>
	let s:p.normal.right = [ ['gray5', 'gray10'],
	      \                  ['gray9', 'gray4'],
	      \                  ['gray8', 'gray2'] ]
<
This array corresponds to the structure of g:lightline.active.right. Recall
the example A.
>
	" Example A
	let g:lightline.active.right = [ [ 'lineinfo', 'syntastic' ],
	      \                          [ 'percent' ],
	      \                          [ 'fileformat', 'fileencoding', 'filetype' ] ]
<
The colors are ([fgcolor, bgcolor):
	(0) [ 'lineinfo', 'syntastic' ]                   ---  s:p.normal.right[0] = ['gray5', 'gray10']
	(1) [ 'percent' ]                                 ---  s:p.normal.right[1] = ['gray9', 'gray4']
	(2) [ 'fileformat', 'fileencoding', 'filetype' ]  ---  s:p.normal.right[2] = ['gray8', 'gray2']


Recall the example B.
>
	" Example B
	let g:lightline.active.right = [ [ 'syntastic', 'lineinfo' ],
	      \                          [ 'percent' ],
	      \                          [ 'fileformat', 'fileencoding', 'filetype' ] ]
<
If a component is specified in |g:lightline.component_expand|, lightline.vim
expands the components before setting to statusline/tabline. In this example,
the syntastic component is expanded using the |SyntasticStatuslineFlag| function.
This function returns a {string}. Let us call it `syntastic_flag`.
>
	let syntastic_flag = SyntasticStatuslineFlag()
<
The syntastic component is now expanded, so it go up to one component group.
The type of the syntastic component is error, and the palette has error
colors, the result is:
>
	" Expanded result of Example B
	(error) [ syntastic_flag ]                            ---  s:p.normal.error[0] = ['gray9', 'brightestred']
	(0)     [ 'lineinfo' ]                                ---  s:p.normal.right[0] = ['gray5', 'gray10']
	(1)     [ 'percent' ]                                 ---  s:p.normal.right[1] = ['gray9', 'gray4']
	(2)     [ 'fileformat', 'fileencoding', 'filetype' ]  ---  s:p.normal.right[2] = ['gray8', 'gray2']
<
Thus the syntastic component has the red color.


Another example for |g:lightline.component_expand| is the tabs component.
Actually, the expand feature is created for the tabs component.
>
	let g:lightline.tabline.left = [ [ 'tabs' ] ]
	let g:lightline.component_expand = {
	    \ 'tabs': 'lightline#tabs' }
<
Create three tabs and select the middle tab. Then execute
>
	echo lightline#tabs()
	" [['%1T%{lightline#onetab(1,0)}'],
	"  ['%2T%{lightline#onetab(2,1)}'],
	"  ['%3T%{lightline#onetab(3,0)}%T']]
<
It returns an array of three elements. The expanded result is:
>
	" Expanded result of tabline
	(0)      ['%1T%{lightline#onetab(1,0)}']    ---  s:p.tabline.left[0] = ['gray9', 'gray4']
	(tabsel) ['%2T%{lightline#onetab(2,1)}']    ---  s:p.tabline.tabsel[0] = ['gray9', 'gray1']
	(0)      ['%3T%{lightline#onetab(3,0)}%T']  ---  s:p.tabline.left[0] = ['gray9', 'gray4']
<
If the tabline components is
>
	let g:lightline.tabline.left = [ [ 'A', 'B', 'tabs', 'C', 'D' ] ]
<
then the expanded result is:
>
	(0)      ['A', 'B', '%1T%{lightline#onetab(1,0)}']    ---  s:p.tabline.left[0]
	(tabsel) ['%2T%{lightline#onetab(2,1)}']              ---  s:p.tabline.tabsel[0]
	(0)      ['%3T%{lightline#onetab(3,0)}%T', 'C', 'D']  ---  s:p.tabline.left[0]
<
In summary, when a function in |g:lightline.component_expand| returns an
array of three elements, the first element and the last element remains as a
part of existing component group. And the middle element goes up to new
component group.
==============================================================================

EXAMPLES					*lightline-examples*
You can configure the appearance of statusline.
Write the following examples in you .vimrc(_vimrc).

In order to change the colorscheme:
>
	let g:lightline = {
		\ 'colorscheme': 'wombat',
		\ }
<

In order to define your own component:
>
	let g:lightline = {
		\ 'active': {
		\   'left': [ [ 'mode', 'paste' ], [ 'myfilename' ] ]
		\ },
		\ 'component_function': {
		\   'myfilename': 'MyFilename',
		\   'myreadonly': 'MyReadonly',
		\   'mymodified': 'MyModified',
		\ }
		\ }
	function! MyFilename()
		return ('' != MyReadonly() ? MyReadonly() . ' ' : '') .
		      \ (&ft == 'vimfiler' ? vimfiler#get_status_string() :
		      \  &ft == 'unite' ? unite#get_status_string() :
		      \ '' != expand('%:t') ? expand('%:t') : '[No Name]') .
		      \ ('' != MyModified() ? ' ' . MyModified() : '')
	endfunction
	function! MyReadonly()
		return &ft !~? 'help' && &readonly ? 'RO' : ''
	endfunction
	function! MyModified()
		return &modifiable && &modified ? '+' : ''
	endfunction
<

Separators settings:
>
	let g:lightline = {
		\ 'separator': { 'left': '', 'right': '' },
		\ 'subseparator': { 'left': '|', 'right': '|' }
		\ }
<

For |powerline| font users:
>
	let g:lightline = {
		\ 'separator': { 'left': '', 'right': '' },
		\ 'subseparator': { 'left': '', 'right': '' }
		\ }
<

For |vim-powerline| font users:
>
	let g:lightline = {
		\ 'separator': { 'left': '⮀', 'right': '⮂' },
		\ 'subseparator': { 'left': '⮁', 'right': '⮃' }
		\ }
<

------------------------------------------------------------------------------
NICE EXAMPLES					*lightline-nice-examples*

A nice example for non-patched font users.
>
	let g:lightline = {
		\ 'colorscheme': 'wombat',
		\ 'active': {
		\   'left': [ [ 'mode', 'paste' ], [ 'fugitive', 'filename' ] ]
		\ },
		\ 'component_function': {
		\   'fugitive': 'MyFugitive',
		\   'filename': 'MyFilename'
		\ }
		\ }
	function! MyModified()
		return &ft =~ 'help\|vimfiler' ? '' : &modified ? '+' : &modifiable ? '' : '-'
	endfunction
	function! MyReadonly()
		return &ft !~? 'help\|vimfiler' && &readonly ? 'RO' : ''
	endfunction
	function! MyFilename()
		return ('' != MyReadonly() ? MyReadonly() . ' ' : '') .
		\ (&ft == 'vimfiler' ? vimfiler#get_status_string() :
		\  &ft == 'unite' ? unite#get_status_string() :
		\  &ft == 'vimshell' ? vimshell#get_status_string() :
		\ '' != expand('%:t') ? expand('%:t') : '[No Name]') .
		\ ('' != MyModified() ? ' ' . MyModified() : '')
	endfunction
	function! MyFugitive()
		if &ft !~? 'vimfiler' && exists("*fugitive#head")
			return fugitive#head()
		endif
		return ''
	endfunction
<
A nice example for |vim-powerline| font users:
>
	let g:lightline = {
		\ 'colorscheme': 'wombat',
		\ 'active': {
		\   'left': [ [ 'mode', 'paste' ], [ 'fugitive', 'filename' ] ]
		\ },
		\ 'component_function': {
		\   'fugitive': 'MyFugitive',
		\   'filename': 'MyFilename'
		\ },
		\ 'separator': { 'left': '⮀', 'right': '⮂' },
		\ 'subseparator': { 'left': '⮁', 'right': '⮃' }
		\ }
	function! MyModified()
		return &ft =~ 'help\|vimfiler' ? '' : &modified ? '+' : &modifiable ? '' : '-'
	endfunction
	function! MyReadonly()
		return &ft !~? 'help\|vimfiler' && &readonly ? '⭤' : ''
	endfunction
	function! MyFilename()
		return ('' != MyReadonly() ? MyReadonly() . ' ' : '') .
		\ (&ft == 'vimfiler' ? vimfiler#get_status_string() :
		\  &ft == 'unite' ? unite#get_status_string() :
		\  &ft == 'vimshell' ? vimshell#get_status_string() :
		\ '' != expand('%:t') ? expand('%:t') : '[No Name]') .
		\ ('' != MyModified() ? ' ' . MyModified() : '')
	endfunction
	function! MyFugitive()
		if &ft !~? 'vimfiler' && exists("*fugitive#head")
			let _ = fugitive#head()
			return strlen(_) ? '⭠ '._ : ''
		endif
		return ''
	endfunction
<

------------------------------------------------------------------------------
POWERFUL EXAMPLE				*lightline-powerful-example*

For users who uses lots of plugins:
>
	let g:lightline = {
	      \ 'colorscheme': 'wombat',
	      \ 'active': {
	      \   'left': [ [ 'mode', 'paste' ], [ 'fugitive', 'filename' ], ['ctrlpmark'] ],
	      \   'right': [ [ 'syntastic', 'lineinfo' ], ['percent'], [ 'fileformat', 'fileencoding', 'filetype' ] ]
	      \ },
	      \ 'component_function': {
	      \   'fugitive': 'MyFugitive',
	      \   'filename': 'MyFilename',
	      \   'fileformat': 'MyFileformat',
	      \   'filetype': 'MyFiletype',
	      \   'fileencoding': 'MyFileencoding',
	      \   'mode': 'MyMode',
	      \   'ctrlpmark': 'CtrlPMark',
	      \ },
	      \ 'component_expand': {
	      \   'syntastic': 'SyntasticStatuslineFlag',
	      \ },
	      \ 'component_type': {
	      \   'syntastic': 'error',
	      \ },
	      \ 'subseparator': { 'left': '|', 'right': '|' }
	      \ }
	
	function! MyModified()
	  return &ft =~ 'help' ? '' : &modified ? '+' : &modifiable ? '' : '-'
	endfunction
	
	function! MyReadonly()
	  return &ft !~? 'help' && &readonly ? 'RO' : ''
	endfunction
	
	function! MyFilename()
	  let fname = expand('%:t')
	  return fname == 'ControlP' ? g:lightline.ctrlp_item :
	        \ fname == '__Tagbar__' ? g:lightline.fname :
	        \ fname =~ '__Gundo\|NERD_tree' ? '' :
	        \ &ft == 'vimfiler' ? vimfiler#get_status_string() :
	        \ &ft == 'unite' ? unite#get_status_string() :
	        \ &ft == 'vimshell' ? vimshell#get_status_string() :
	        \ ('' != MyReadonly() ? MyReadonly() . ' ' : '') .
	        \ ('' != fname ? fname : '[No Name]') .
	        \ ('' != MyModified() ? ' ' . MyModified() : '')
	endfunction
	
	function! MyFugitive()
	  try
	    if expand('%:t') !~? 'Tagbar\|Gundo\|NERD' && &ft !~? 'vimfiler' && exists('*fugitive#head')
	      let mark = ''  " edit here for cool mark
	      let _ = fugitive#head()
	      return strlen(_) ? mark._ : ''
	    endif
	  catch
	  endtry
	  return ''
	endfunction
	
	function! MyFileformat()
	  return winwidth('.') > 70 ? &fileformat : ''
	endfunction
	
	function! MyFiletype()
	  return winwidth('.') > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
	endfunction
	
	function! MyFileencoding()
	  return winwidth('.') > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
	endfunction
	
	function! MyMode()
	  let fname = expand('%:t')
	  return fname == '__Tagbar__' ? 'Tagbar' :
	        \ fname == 'ControlP' ? 'CtrlP' :
	        \ fname == '__Gundo__' ? 'Gundo' :
	        \ fname == '__Gundo_Preview__' ? 'Gundo Preview' :
	        \ fname =~ 'NERD_tree' ? 'NERDTree' :
	        \ &ft == 'unite' ? 'Unite' :
	        \ &ft == 'vimfiler' ? 'VimFiler' :
	        \ &ft == 'vimshell' ? 'VimShell' :
	        \ winwidth('.') > 60 ? lightline#mode() : ''
	endfunction
	
	function! CtrlPMark()
	  if expand('%:t') =~ 'ControlP'
	    call lightline#link('iR'[g:lightline.ctrlp_regex])
	    return lightline#concatenate([g:lightline.ctrlp_prev, g:lightline.ctrlp_item
	          \ , g:lightline.ctrlp_next], 0)
	  else
	    return ''
	  endif
	endfunction
	
	let g:ctrlp_status_func = {
	  \ 'main': 'CtrlPStatusFunc_1',
	  \ 'prog': 'CtrlPStatusFunc_2',
	  \ }
	
	function! CtrlPStatusFunc_1(focus, byfname, regex, prev, item, next, marked)
	  let g:lightline.ctrlp_regex = a:regex
	  let g:lightline.ctrlp_prev = a:prev
	  let g:lightline.ctrlp_item = a:item
	  let g:lightline.ctrlp_next = a:next
	  return lightline#statusline(0)
	endfunction
	
	function! CtrlPStatusFunc_2(str)
	  return lightline#statusline(0)
	endfunction
	
	let g:tagbar_status_func = 'TagbarStatusFunc'
	
	function! TagbarStatusFunc(current, sort, fname, ...) abort
	    let g:lightline.fname = a:fname
	  return lightline#statusline(0)
	endfunction
	
	augroup AutoSyntastic
	  autocmd!
	  autocmd BufWritePost *.c,*.cpp call s:syntastic()
	augroup END
	function! s:syntastic()
	  SyntasticCheck
	  call lightline#update()
	endfunction
	
	let g:unite_force_overwrite_statusline = 0
	let g:vimfiler_force_overwrite_statusline = 0
	let g:vimshell_force_overwrite_statusline = 0
<
------------------------------------------------------------------------------
TROUBLESHOOTING					*lightline-troubleshooting*

Problem 1:				|lightline-problem-1|
	How to install this plugin.

Problem 2:				|lightline-problem-2|
	How to update this plugin.

Problem 3:				|lightline-problem-3|
	How to uninstall this plugin.

Problem 4:				|lightline-problem-4|
	Cool statuslines appear only on |:vsp|.

Problem 5:				|lightline-problem-5|
	The statusline does not seem to be correctly colored.

Problem 6:				|lightline-problem-6|
	How to install a patched font.

Problem 7:				|lightline-problem-7|
	Right triangles do not stick to the right components with the
	patched font.

Problem 8:				|lightline-problem-8|
	Triangles look weird.

Problem 9:				|lightline-problem-9|
	Where can I find the list of all the cool characters for patched fonts?

Problem 10:				|lightline-problem-10|
	Cool statusline disappears in |unite|, |vimfiler| and |vimshell|
	buffers.

Problem 11:				|lightline-problem-11|
	Cool statusline disappears in |CtrlP|, |Tagbar| buffers.

Problem 12:				|lightline-problem-12|
	How to change the lightline colorscheme on the fly.

Problem 13:				|lightline-problem-13|
	Found a bug of this plugin.
	Got many errors while using this plugin.
	Vim hangs while using this plugin.
	Want this plugin to be more configurable.
	This troubleshooting is not helpful.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Problem 1:					*lightline-problem-1*
	How to install this plugin.

		If you are to install this plugin manually:

			1. Put all the files under $VIM.

		If you are using |vim-pathogen|, install this plugin with the
		following command.
>
			git clone https://github.com/itchyny/lightline.vim \
			    ~/.vim/bundle/lightline.vim
<
		If you are to install this plugin using |Vundle|:

			1. Add the following configuration to your
			.vimrc(_vimrc).
>
			Bundle 'itchyny/lightline.vim'
<
			2. Install with |:BundleInstall|.

		If you are to install this plugin using |NeoBundle|:

			1. Add the following configuration to your
			.vimrc(_vimrc).
>
			NeoBundle 'itchyny/lightline.vim'
<
			2. Install with |:NeoBundleInstall|.

Problem 2:					*lightline-problem-2*
	How to update this plugin.

		If you have installed this plugin manually:

			1. Access https://github.com/itchyny/lightline.vim .
			2. Download the latest scripts.
			3. Place the scripts as written in Problem 1.

		If you have installed this plugin using Vundle:

			1. Execute |:BundleInstall!|. Or try git pull in the
			directory of this plugin.

		If you have installed this plugin using NeoBundle:

			1. Execute |:NeoBundleInstall!|. Or try git pull in
			the directory of this plugin.

Problem 3:					*lightline-problem-3*
	How to uninstall this plugin.

		If you have installed this plugin manually:

			1. Remove all the lightline.*s under $VIM.

		If you have installed this plugin using Vundle:

			1. Remove the :Bundle 'itchyny/lightline.vim'
			configuration from your .vimrc(_vimrc).
			2. Update with |:BundleClean|.

		If you have installed this plugin using NeoBundle:

			1. Remove the :NeoBundle 'itchyny/lightline.vim'
			configuration from your .vimrc(_vimrc).
			2. Update with |:NeoBundleClean|.

Problem 4:					*lightline-problem-4*
	Cool statuslines appear only on |:vsp|.

		Add the following setting to your .vimrc(_vimrc).
>
			set laststatus=2
<
Problem 5:					*lightline-problem-5*
	The statusline does not seem to be correctly colored.

		Add
>
			export TERM=xterm-256color
<
		to your .*shrc and add
>
			if !has('gui_running')
			  set t_Co=256
			endif
<
		to your .vimrc(_vimrc).

Problem 6:					*lightline-problem-6*
	How to install a patched font.

		There are two kinds of patched fonts:

		+ The patched fonts for |vim-powerline|
		(https://github.com/Lokaltog/vim-powerline):
		follow the guide https://github.com/Lokaltog/vim-powerline/tree/develop/fontpatcher
		+ The patched fonts for |powerline|
		(https://github.com/Lokaltog/powerline):
		download from https://github.com/Lokaltog/powerline-fonts

Problem 7:					*lightline-problem-7*
	Right triangles do not stick to the right components with patched
	font.

		Remove the following setting from your .vimrc(_vimrc).
>
			set ambiwidth=double
<
		If you want to keep this setting, try the patched font for
		|vim-powerline|.

Problem 8:					*lightline-problem-8*
	Triangles look weird.

		If you are using iTerm2, change the following settings.

		    + set Profiles>Colors>Minimum contrast to the Lowest.
		    + set Profiles>Window>Transparency to the Opaquest.

		For other terminals, this weird-triangle problem will be
		resolved by disabling transparency or contrast adjustment.

Problem 9:					*lightline-problem-9*
	Where can I find the list of all the cool characters for patched fonts?

				Default		powerline	vim-powerline
	separator.left		''		''		'⮀'
	separator.right		''		''		'⮂'
	subseparator.left	'|'		''		'⮁'
	subseparator.right	'|'		''		'⮃'
	branch symbol		--		''		'⭠'
	readonly symbol		--		''		'⭤'
	linecolumn symbol	--		''		'⭡'

Problem 10:					*lightline-problem-10*
	Cool statusline disappears on |unite|, |vimfiler| and |vimshell|
	buffers.

		Add the following settings to your .vimrc(_vimrc).
>
		let g:unite_force_overwrite_statusline = 0
		let g:vimfiler_force_overwrite_statusline = 0
		let g:vimshell_force_overwrite_statusline = 0
<
Problem 11:					*lightline-problem-11*
	Cool statusline disappears in |CtrlP|, |Tagbar| buffers.

		Add the following settings to your .vimrc(_vimrc).
>
		let g:ctrlp_status_func = {
		  \ 'main': 'CtrlPStatusFunc_1',
		  \ 'prog': 'CtrlPStatusFunc_2',
		  \ }
		function! CtrlPStatusFunc_1(focus, byfname, regex, prev, item, next, marked)
		  return lightline#statusline(0)
		endfunction
		function! CtrlPStatusFunc_2(str)
		  return lightline#statusline(0)
		endfunction
		
		let g:tagbar_status_func = 'TagbarStatusFunc'
		function! TagbarStatusFunc(current, sort, fname, ...) abort
		  return lightline#statusline(0)
		endfunction
<
		See |lightline-powerful-example| for more cool settings for
		these plugins.

Problem 12:					*lightline-problem-12*
	How to change the lightline colorscheme on the fly.

		Add the following settings to your .vimrc(_vimrc).
>
		augroup LightLineColorscheme
		  autocmd!
		  autocmd ColorScheme * call s:lightline_update()
		augroup END
		function! s:lightline_update()
		  if !exists('g:loaded_lightline')
		    return
		  endif
		  try
		    if g:colors_name =~# 'wombat\|solarized\|landscape\|jellybeans\|Tomorrow'
		      let g:lightline.colorscheme =
		            \ substitute(substitute(g:colors_name, '-', '_', 'g'), '256.*', '', '') .
		            \ (g:colors_name ==# 'solarized' ? '_' . &background : '')
		      call lightline#init()
		      call lightline#colorscheme()
		      call lightline#update()
		    endif
		  catch
		  endtry
		endfunction
<
Problem 13:					*lightline-problem-13*
	Found a bug of this plugin.
	Got many errors while using this plugin.
	Vim hangs while using this plugin.
	Want this plugin to be more configurable.
	This troubleshooting is not helpful.

		Report/Request the issue/feature at
		https://github.com/itchyny/lightline.vim/issues .


==============================================================================
CHANGELOG					*lightline-changelog*

0.0	2013-08-21, ...
	- Initial commit and implementation

==============================================================================
vim:tw=78:sw=4:ts=8:ft=help:norl:noet:
